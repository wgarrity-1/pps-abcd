<?php
# William Garrity
# 12/30/2020
# This program contains the functions getNeededDates(), determineDays(), convertDateFormat(), and DetermineTodaysSchedule() which helps to determine what the current day type is, the next 5 day types, as well as the current day's schedule. It also contains all of the schedules that the school uses

define('DATE_FORMAT', "l, F j, Y");
define('DISPLAY_FORMAT', "l, F jS");

define('BOOLEAN_REMOTE', true);

# function determines the current date, formats it, then determines the dates for the next 5 days, then formats thoes dates to the format of the dates stored in the DB, stores it all in an array, then returns that array. You can also customize the number of dates this function puts out.
function getNeededDates($num_dates = 5, $date_format = DATE_FORMAT){
    
    # variable the stores the current date
    $current_date = new DateTime();
    
    # formats the current date with the format specified (either set in the function or the default)
    $current_date_formatted = $current_date->format($date_format);
    
    # creates a new array called and sets the 0th index to be the current date formatted
    $all_dates = [$current_date_formatted];
    
    # this for loop will run 5 times, starting from 1 and stopping when it hits $num_dates + 1. Starts at 1 so that 1 day is added on later
    for ($i = 1; $i < $num_dates + 1; $i++){
        # sets $fresh_current_date to the current date so that the calculations below won't be messed up
        $fresh_current_date = clone $current_date;
        
        # sets #added_date to $i days after the current date ($i depends on what part of the loop the for loop is at, that is also why $i starts at one so that 1 day is added)
        $added_date = $fresh_current_date->add(new DateInterval("P{$i}D"));
        
        # pushed $added_date to the array with it formatted
        array_push($all_dates, $added_date->format($date_format));
    }
    
    # returns the array that was created in this function
    return $all_dates;

}

# function that takes an array of dates (going to be used in conjunction with the getNeededDates function), and goes through the database to find the entries for thoes dates given, then combines all entries into one array called $day_and_type which is returned
function determineDays($db_file, $date_array, $date_format = DATE_FORMAT, $display_format = DISPLAY_FORMAT){
    # empty array for use later
    $day_and_type = [];
    
    # opens the sqlite database using PDO
    $pdo = new PDO("sqlite:{$db_file}");
    
    # stmt stores the prepared statement which will select all collumns from the table Days where the date matches the date given in the variable $date, which is binded to the :date thingy
    $stmt = $pdo->prepare("SELECT * FROM Days WHERE Date = :date");
    $stmt->bindParam(':date', $date);
    
    # for every $date in $date array
    foreach ($date_array as $date){
        # executes the statement with the date variable, and then sets the output of it to a Key Pair (date => type of day array)
        $stmt->execute();
        $result = $stmt->setFetchMode(PDO::FETCH_KEY_PAIR);
        
        # fetches the result of the statement and stores it in $result
        $result = $stmt->fetchAll();
        
        # for every $date and $type_of_day in the result 
        foreach ($result as $date => $type_of_day){
            
            # formats the date into the display format using the function below, changes the date into the format Weekday, Month Day[th] so that it can be used to get the right day display on the main page
            $formatted_date = convertDateFormat($date, $date_format, $display_format);
            
            # appends the $formatted_date and $type_of_day to the $day_and_type variable
            $day_and_type[$formatted_date] = $type_of_day;
        }
        
    }
    
    # closed the PDO session
    $pdo = null;
    
    # returns the associative array $day_and_type
    return $day_and_type;
}


# this function easily converts one date string format to another
function convertDateFormat($date, $old_date_format, $new_date_format){
    # takes the given date and converts it into a DateTime object using the old format
    $new_date = DateTime::createFromFormat($old_date_format, $date);
    
    # takes the DateTime object and formats it into the new date format
    $new_date_formatted = $new_date->format($new_date_format);

    #returns the new formatted date
    return $new_date_formatted;
}

# schedules as arrays because I really don't think there is a need for them to be generated by any loop or function

# schedule for A and B days remote
$ab_remote_schedule = [
    "b1" => "<td class='periodset-1'>Period 1 - Remote</td>",
    "b2" => "<td class='periodset-1'>Period 2 - Remote</td>",
    "b3" => "<td class='periodset-1'>Period 3 - Remote</td>",
    "lunch" => "<td class='organizeset'>Lunch and Organize Block</td>",
    "b4" => "<td class='periodset-2'>Period 4 - Remote</td>",
    "b5" => "<td class='periodset-2'>Period 5 - Remote</td>",
    "b6" => "<td class='periodset-2'>Period 6 - Remote</td>"
];

# schedule for C and D days remote
$cd_remote_schedule = [
    "b1" => "<td class='periodset-2'>Period 4 - Remote</td>",
    "b2" => "<td class='periodset-2'>Period 5 - Remote</td>",
    "b3" => "<td class='periodset-2'>Period 6 - Remote</td>",
    "lunch" => "<td class='organizeset'>Lunch and Organize Block</td>",
    "b4" => "<td class='periodset-1'>Period 1 - Remote</td>",
    "b5" => "<td class='periodset-1'>Period 2 - Remote</td>",
    "b6" => "<td class='periodset-1'>Period 3 - Remote</td>"
];

# blank schedule for days that students don't have school "weekends and breaks"
$day_off_schedule = [
    "b1" => "<td></td>",
    "b2" => "<td></td>",
    "b3" => "<td></td>",
    "lunch" => "<td></td>",
    "b4" => "<td></td>",
    "b5" => "<td></td>",
    "b6" => "<td></td>"
];

# function that takes in the current type of day, and then decides which schedule it should return based on the type of day and if school is remote or not
function determineTodaysSchedule($current_day_type){
    
    # globals all of the hardcoded schedules
    global $ab_remote_schedule, $cd_remote_schedule, $day_off_schedule;
    
    # if the constant BOOLEAN_REMOTE is true (which is set to true if school is remote), give only remote schedules, else give hybrid schedules
    if (BOOLEAN_REMOTE){
        
        # if the current day is an A or B day, return $ab_remote_schedule
        if($current_day_type === 'A' or $current_day_type === 'B'){
            return $ab_remote_schedule;
        # if the current day is an C or D day, return $cd_remote_schedule
        } else if($current_day_type === 'C' or $current_day_type === 'D'){
            return $cd_remote_schedule;
        # otherwise, return the $day_off_schedule
        } else{
            return $day_off_schedule;
        }
        
    } else{
        # hybrid schedules haven't come out yet so this part of the program is blank
    }
}